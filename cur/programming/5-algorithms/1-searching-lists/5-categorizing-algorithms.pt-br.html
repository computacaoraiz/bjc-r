<!DOCTYPE html>
<html lang="pt-br">
	<head>
		<meta charset="utf-8">
		<script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
		<title>Unidade 5 Laboratório 1: Algoritmos de Busca e Eficiência, Página 5</title>
	</head>

	<body>
		<h2>Categorizando Algoritmos</h2>
        <div class="todo">
            <h3>TG e soluções precisam ser verificados. --MF, 19/12/18</h3>
        </div>
        <div class="learn"><strong>Nesta página</strong>, você irá comparar quatro algoritmos e aprender como cada um deles leva uma categoria diferente de tempo para ser executado.</div>

        <div class="forYouToDo" id="first">
			<ol>
				<li>
                    Localize o bloco <img src="/bjc-r/img/5-algorithms/25000integers.png" alt="25.000 inteiros a partir de ()" title="25.000 inteiros a partir de ()" /> incluído em seu projeto e cronometre-o para vários números iniciais.<br />
                    <table class="bordered center standard" summary="tabela mostrando o número de tentativas necessárias para encontrar o último número em uma lista ordenada de um determinado tamanho">
                        <tr>
                            <th scope="col">Número Inicial</th>
                            <th scope="col">Tempo de <code>25.000 inteiros</code></th>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10.000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100.000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1.000.000</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10.000.000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li><img class="imageRight" src="/bjc-r/img/icons/talk-with-your-partner.png" alt="Converse com o seu parceiro" title="Converse com o seu parceiro" /> Olhe para a tabela. Como você descreveria o que acontece com o tempo à medida que o número inicial fica maior? Escreva uma hipótese sobre o padrão.</li>
                <li>
                    <div class="sidenoteBig">Existem várias maneiras diferentes de classificar uma lista, algumas das quais você aprenderá na Unidade 8. Este bloco de <code>ordenar</code> utiliza um algoritmo de "ordenação por inserção".</div>
                    Localize o bloco <img class="inline nopadtb" src="/bjc-r/img/5-algorithms/sort.png" alt="ordenar 'slot de entrada da lista'" title="ordenar 'slot de entrada da lista'" /> incluído em seu projeto e cronometre-o para cada lista de comprimento.<br />
                    <table class="bordered center standard" summary="tabela mostrando o número de tentativas necessárias para encontrar o último número em uma lista ordenada de um determinado tamanho">
                        <tr>
                            <th scope="col">Comprimento da Lista</th>
                            <th scope="col">Tempo de <code>Ordenar</code></th>
                        </tr>
                        <tr>
                            <td>10</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>100</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1000</td>
                            <td></td>
                        </tr>
                    </table>
                </li>
                <li><img class="inline" src="/bjc-r/img/icons/talk-with-your-partner-mini.png" alt="Converse com o seu parceiro" title="Converse com o seu parceiro" /> Como você descreveria o que acontece com o tempo à medida que o tamanho da lista de entrada fica maior? Escreva uma hipótese.</li>
			</ol>
		</div>

        <p>É possível classificar os algoritmos de acordo com a quantidade de tempo que eles levam para serem executados. <!--Para classificar um algoritmo, você analisa o número de passos necessários para completar o algoritmo e compara-o com o tamanho da entrada. Por exemplo, <code>25.000 inteiros</code> leva <em>tempo constante:</em> calcular 25.000 inteiros a partir do número sete leva o mesmo tempo que calcular 25.000 inteiros a partir do número sete milhões. Como segundo exemplo, a <code>busca linear</code> leva <em>tempo linear:</em> se você tiver dez vezes mais palavras no dicionário, levará dez vezes mais tempo para procurar por todas elas. Como terceiro exemplo, considere o algoritmo de <code>ordenar</code> que você cronometrou. Ele leva <em>tempo quadrático:</em> multiplicar o tamanho da entrada por dez multiplica o tempo necessário por 10<sup>2</sup>. Como outro exemplo, considere o algoritmo de <code>busca binária</code> que você cronometrou. Na busca binária, multiplicar o tamanho da entrada por dez <em>adiciona</em> uma quantidade constante de tempo ao invés de multiplicar por uma quantidade constante. Isso é um exemplo de <em>tempo sublinear</em>.--></p>

        <div class="forYouToDo">
        <div class="vocabBig">
            <ul>
                <li>Um algoritmo leva <strong>tempo linear</strong> se o número de passos for proporcional ao tamanho da entrada; dobrar o tamanho da entrada dobra o tempo necessário.</li>
                <li>Um algoritmo leva <strong>tempo sublinear</strong> se o número de passos crescer mais lentamente do que o tamanho da entrada.</li>
                <li>Um algoritmo leva <strong>tempo constante</strong> se ele levar o mesmo número de passos, independentemente do tamanho da entrada.</li>
                <li>Um algoritmo leva <strong>tempo quadrático</strong> se o número de passos for proporcional ao <em>quadrado</em> do tamanho da entrada.</li>
            </ul>
        </div>
			<ol start="5">
				<li>Reveja sua tabela para a <code>busca linear</code>. Confirme que multiplicar o tamanho da lista por dez aproximaadamente multiplica o tempo por dez (<em>tempo linear</em>).<!--o tempo de busca para a lista de <var>100.000 palavras</var> é (aproximadamente) dez vezes maior do que o tempo para a lista de <var>10.000 palavras</var>, que é (aproximadamente) dez vezes maior do que o tempo para a lista de <var>1.000 palavras</var>.--></li>
				<li>Reveja sua tabela para a <code>busca binária</code>. Confirme que o tempo de busca para cada lista de palavras é menor do que para a busca linear (<em>tempo sublinear</em>).</li>
                <li>Reveja sua tabela para <code>25.000 inteiros</code>. Confirme que leva aproximadamente o mesmo tempo, independentemente da entrada (<em>tempo constante</em>).</li>
				<li>Reveja sua tabela para <code>ordenar</code>. Confirme que multiplicar o tamanho da lista por dez aproximaadamente multiplica o tempo por cem (<em>tempo quadrático</em>).<!--Confirme que o tempo para ordenar a lista de <var>100.000 palavras</var> é (aproximadamente) cem vezes maior do que o tempo para a lista de <var>10.000 palavras</var>, que é (aproximadamente) cem vezes maior do que o tempo para a lista de <var>1.000 palavras</var>.--></li>
			</ol>
		</div>

        <p>A diferença entre a busca linear e a busca binária pode ser muito importante se você estiver procurando em uma lista de dez milhões de itens, mas a diferença mais importante na eficiência dos algoritmos está entre o tempo polinomial (proporcional a qualquer potência do tamanho da entrada) e o tempo exponencial.</p>

        <div class="vocabFullWidth">
            <ul>
                <li>
                    Um algoritmo leva <strong>tempo polinomial</strong> se o número de passos for menor ou igual a uma potência do tamanho da entrada, como constante (<em>n</em><sup>0</sup>), sublinear, linear (<em>n</em><sup>1</sup>), quadrático (<em>n</em><sup>2</sup>), ou cúbico (<em>n</em><sup>3</sup>).
                </li>
                <li>
                    Um algoritmo leva <strong>tempo exponencial</strong> se o número de passos for proporcional a uma função exponencial do tamanho da entrada, como 2<sup><em>n</em></sup>, 10<sup><em>n</em></sup>, etc., que é muito mais lento do que qualquer tempo polinomial.
                </li>
            </ul>
        </div>
        <p>Em um algoritmo de tempo exponencial, apenas <em>adicionar 1</em> ao tamanho da entrada (<em>n</em>) de um algoritmo de tempo 2<sup><em>n</em></sup> <em>dobra</em> o número de passos! Portanto, por exemplo, se o tamanho da entrada for 20, <em>qualquer</em> algoritmo de tempo polinomial será rápido o suficiente, mas um algoritmo de tempo exponencial pode levar muitos <em>anos</em> para ser concluído.</p>

        <div class="commentBig">diminuir a animação, adicionar rótulos, tornar o gráfico exponencial em vermelho e corrigir problemas estranhos nos gráficos; a imagem também precisa de texto alternativo como o que está no texto comentado aqui. --MF, 2/4/19</div>
        <img class="indent noshadow" src="/bjc-r/img/5-algorithms/algorithm-time-graphs.gif" alt="" title="" /><br />

        <div class="examFullWidth">
            <ul>
                <div class="ap-standard">AAP-4.A.7</div>
                <li>O termo "<strong>tempo razoável</strong>" descreve qualquer algoritmo que execute em tempo polinomial. Algoritmos de tempo exponencial <em>não</em> são considerados razoáveis.</li>
            </ul>
        </div>

        <div class="todo"><div class="endnote">Na internet, muitas pessoas usam a palavra "exponencial" para significar "acontecendo muito rápido", como em exemplos de manchetes sensacionalistas. -versão mais educada: agora você sabe melhor-</div></div>

        <!--<img class="indent noshadow" style="height:300px" src="/bjc-r/img/5-algorithms/size-vs-time.png" alt="gráfico de tamanho versus tempo mostrando uma linha reta passando pela origem e subindo para a direita com os pontos para x=10.000 e x=100.000 marcados" title="gráfico de tamanho versus tempo mostrando uma linha reta passando pela origem e subindo para a direita com os pontos para x=10.000 e x=100.000 marcados" />-->

        <div class="ap-standard">AAP-2.M.2 texto antes das balas</div>
        <p>Uma razão pela qual vale a pena aprender essas categorias é evitar reinventar a roda. Por exemplo, você aprendeu que se uma lista estiver ordenada, você pode buscá-la em tempo sublinear usando a busca binária. Portanto, ao escrever um programa que precisa buscar repetidamente em uma lista, vale a pena ordenar a lista antes de procurar. Conhecer os algoritmos que já existem pode ajudá-lo a construir novos algoritmos.</p>

        <p>Todos os algoritmos que você explorou até agora neste laboratório (<code>busca linear</code>; <code>busca binária</code>; <code>25.000 inteiros</code>; e <code>ordenar</code>) são algoritmos de tempo razoável. A atividade opcional a seguir é um exemplo de um algoritmo de tempo exponencial.</p>
        <div class="ifTime">
            <ol start="9">
                <p>Um problema que pode ser familiar e que requer um algoritmo de tempo exponencial é calcular qualquer elemento específico do Triângulo de Pascal. No Triângulo de Pascal, cada número é encontrado somando os dois números acima dele. Por exemplo, 4 + 6 = 10 e 15 + 6 = 21, como mostrado abaixo. O primeiro e o último número de cada linha, que não têm dois números acima deles, são 1. <br />
                    <img class="indent noshadow" src="/bjc-r/img/5-algorithms/pascals-triangle-numbers.jpg" alt="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1" title="
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1
   1 6 15 20 15 6 1
 1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1" />
                <img class="indent" src="/bjc-r/img/5-algorithms/pascals-triangle-6-3-reporting.png" alt="triângulo de pascal, linha: (6) posição: (3) relatando 10" title="triângulo de pascal, linha: (6) posição: (3) relatando 10" />
                </p>
                <li>
                    Localize o bloco <img class="inline" src="/bjc-r/img/8-recursive-reporters/pascals-triangle.png" alt="triângulo de pascal, linha: () posição: ()" title="triângulo de pascal, linha: () posição: ()" /> incluído em seu projeto e cronometre-o para várias entradas.<br />
                    <div class="endnote">Se demorar muito para ser executado, você pode interromper o programa; apenas preencha a tabela até onde a velocidade do seu computador permitir.</div>
                    <table class="bordered center" summary="tabela mostrando o número de tentativas necessárias para encontrar o último número em uma lista ordenada de determinado comprimento">
                        <tr>
                            <th scope="col" style="white-space: nowrap;">Entradas</th>
                            <th scope="col" style="white-space: nowrap;">Tempo do Triângulo de Pascal</th>
                        </tr>
                        <tr>
                            <td>5, 2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10, 5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>15, 7</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>20, 10</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>25, 12</td>
                            <td></td>
                        </tr>
                    </table>
                    <div class="endnote">O valor de <var>linha</var> é a entrada para <code>triângulo de pascal</code> que importa. (A entrada de <var>posição</var> é fornecida apenas para obter o tempo para uma das posições perto do meio da linha, que leva mais tempo para calcular.)</div>
                    <p>Essas entradas de <var>linha</var> são muito pequenas em comparação com o tamanho da entrada para os algoritmos de <code>busca linear</code>, <code>busca binária</code> e <code>ordenar</code>, e ainda assim o tempo necessário para <code>triângulo de pascal</code> é muito maior. Seu computador provavelmente não pode ir muito além de <var>25</var>.</p>
                    <div class="endnote">Este algoritmo funciona adicionando os dois números acima usando o algoritmo dentro de si mesmo de forma recursiva, mas existem algoritmos melhores que calculam o valor de um número no Triângulo de Pascal em tempo linear.</div>
                </li>
                </ol>
                </div>

                <div class="forYouToDo">
                <ol start="10">
                <div class="ap-standard">AAP-4.A parte a</div>
                <li>Escreva um parágrafo explicando a diferença entre algoritmos que são executados em um tempo razoável e aqueles que não são.</li>
                <li>
                    Esta pergunta é semelhante às que você verá no exame AP CSP.
                    <!-- Pergunta 1 -->
                    <div class="assessment-data" type="multiplechoice" identifier="Tempo de tarefas de banco de dados"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="true">
                        <div prompt="">
                            A tabela abaixo mostra o tempo do computador necessário para concluir várias tarefas nos dados de cidades de tamanhos diferentes.
                            <p>
                                <table class="bordered center standard" summary="horas necessárias para várias tarefas de gerenciamento de dados para cidades de vários tamanhos">
                                    <tr>
                                        <th scope="col">Tarefa</th>
                                        <th scope="col">Cidade Pequena<br />(população 1.000)</th>
                                        <th scope="col">Cidade de Tamanho Médio<br />(população 10.000)</th>
                                        <th scope="col">Cidade Grande<br />(população 100.000)</th>
                                    </tr>
                                    <tr>
                                        <th scope="row">Inserção de Dados</th>
                                        <td>2 horas</td>
                                        <td>20 horas</td>
                                        <td>200 horas</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Backup de Dados</th>
                                        <td>0,5 horas</td>
                                        <td>5 horas</td>
                                        <td>50 horas</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Pesquisa de Dados</th>
                                        <td>5 horas</td>
                                        <td>15 horas</td>
                                        <td>25 horas</td>
                                    </tr>
                                    <tr>
                                        <th scope="row">Classificação de Dados</th>
                                        <td>0,01 hora</td>
                                        <td>1 hora</td>
                                        <td>100 horas</td>
                                    </tr>
                                </table>
                            </p>
                            Com base nas informações na tabela, qual das seguintes tarefas é mais provável que leve <em><strong>mais tempo</strong></em> quando dimensionada para uma cidade com uma população de 1.000.000 habitantes.
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">Inserção de dados</div>
                            <div class="feedback">
                                <!-- A inserção de dados parece levar <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-entering-data.jpg" alt="população/1000" title="população/1000" /> horas, portanto, para uma população de 1.000.000 habitantes, deve levar cerca de 2.000 horas.-->
                                À medida que o tamanho da população é multiplicado por 10, o tempo necessário para inserção de dados também é multiplicado por 10, portanto, para uma população de 1.000.000, deve levar cerca de 10&times;200=2000 horas.
                            </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">Backup de dados</div>
                            <div class="feedback">
                                <!-- O backup de dados parece levar cerca de <img class="inline noshadow nopad" src="/bjc-r/img/5-algorithms/quizlet-backing-up.jpg" alt="5^((população/1000)-1)" title="5^((população/1000)-1)" /> horas, portanto, para uma população de 1.000.000 habitantes, deve levar cerca de 125 horas.-->
                                À medida que o tamanho da população é multiplicado por 10, o tempo necessário para o backup de dados também é multiplicado por 10, portanto, para uma população de 1.000.000, deve levar cerca de 10&times;50=500 horas.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">Pesquisa de dados</div>
                            <div class="feedback">
                                A pesquisa nos dados parece aumentar cerca de 10 horas cada vez que a população é multiplicada por 10, portanto, para uma população de 1.000.000 habitantes, deve levar cerca de 35 horas.
                            </div>
                        </div>
                        <div class "choice" identifier = "c4">
                            <div class = "text">Classificação de dados</div>
                            <div class = "feedback">
                                Correto! <!--A classificação dos dados parece aumentar exponencialmente à medida que a população cresce. Para uma população de 1.000.000 habitantes, deve levar cerca de 10.000 horas.--> À medida que o tamanho da população é multiplicado por 10, o tempo necessário para a classificação de dados é multiplicado por 100. Portanto, para uma população de 1.000.000 habitantes, deve levar cerca de 100&times;100=10.000 horas.
                            </div>
                        </div>
                        <div class = "responseDeclaration" identifier = "ri1">
                            <div class = "correctResponse" identifier = "c4"> </div>
                        </div>
                    </div>
                </li>
            </ol>
        </div>
    </body>
</html>